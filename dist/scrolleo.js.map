{"version":3,"file":"scrolleo.js","sources":["../src/dom.js","../src/debug.js","../src/generateId.js","../src/err.js","../src/getIndex.js","../src/createProgressThreshold.js","../src/parseOffset.js","../src/indexSteps.js","../src/getOffsetTop.js","../src/scroll.js","../src/entry.js"],"sourcesContent":["// DOM helper functions\n\n// public\nfunction selectAll(selector, parent = document) {\n\tif (typeof selector === 'string') {\n\t\treturn Array.from(parent.querySelectorAll(selector));\n\t} else if (selector instanceof Element) {\n\t\treturn [selector];\n\t} else if (selector instanceof NodeList) {\n\t\treturn Array.from(selector);\n\t} else if (selector instanceof Array) {\n\t\treturn selector;\n\t}\n\treturn [];\n}\n\nexport { selectAll };\n","// Module-level overlay element - single reusable overlay for all steps\nlet overlayElement = null;\n\n// SETUP\nfunction create() {\n\tconst el = document.createElement('div');\n\tel.className = 'scrollama__debug-step';\n\tel.style.position = 'fixed';\n\tel.style.left = '0';\n\tel.style.width = '100%';\n\tel.style.zIndex = '9999';\n\tel.style.borderTop = '2px solid black';\n\tel.style.borderBottom = '2px solid black';\n\n\tconst p = document.createElement('p');\n\tp.style.position = 'absolute';\n\tp.style.left = '0';\n\tp.style.height = '1px';\n\tp.style.width = '100%';\n\tp.style.borderTop = '1px dashed black';\n\n\tel.appendChild(p);\n\tdocument.body.appendChild(el);\n\treturn el;\n}\n\n// UPDATE\nfunction update({ id, step, marginTop }) {\n\tconst { height } = step;\n\n\t// Create overlay if it doesn't exist\n\tif (!overlayElement) {\n\t\toverlayElement = create();\n\t}\n\n\t// Update position and size for current step\n\toverlayElement.style.top = `${marginTop * -1}px`;\n\toverlayElement.style.height = `${height}px`;\n\toverlayElement.querySelector('p').style.top = `${height / 2}px`;\n}\n\n// CLEANUP\nfunction cleanup() {\n\tif (overlayElement) {\n\t\toverlayElement.remove();\n\t\toverlayElement = null;\n\t}\n}\n\nexport { update, cleanup };\n","export default function generateId() {\n\tconst alphabet = 'abcdefghijklmnopqrstuvwxyz';\n\tconst date = Date.now();\n\tconst result = [];\n\tfor (let i = 0; i < 6; i += 1) {\n\t\tconst char = alphabet[Math.floor(Math.random() * alphabet.length)];\n\t\tresult.push(char);\n\t}\n\treturn `${result.join('')}${date}`;\n}\n","export default function err(msg) {\n\tconsole.error(`scrollama error: ${msg}`);\n}\n","// WeakMap for fast index lookups without DOM attribute reads\nconst stepIndexMap = new WeakMap();\n\nexport function setIndex(node, index) {\n\tstepIndexMap.set(node, index);\n}\n\nexport default function getIndex(node) {\n\treturn stepIndexMap.get(node);\n}\n","export default function createProgressThreshold(height, threshold) {\n\tconst count = Math.ceil(height / threshold);\n\tconst t = [];\n\tconst ratio = 1 / count;\n\tfor (let i = 0; i < count + 1; i += 1) {\n\t\tt.push(i * ratio);\n\t}\n\treturn t;\n}\n","export default function parseOffset(x) {\n\tif (typeof x === 'string' && x.indexOf('px') > 0) {\n\t\tconst v = +x.replace('px', '');\n\t\tif (!isNaN(v)) return { format: 'pixels', value: v };\n\t\telse {\n\t\t\terr(\"offset value must be in 'px' format. Fallback to 0.5.\");\n\t\t\treturn { format: 'percent', value: 0.5 };\n\t\t}\n\t} else if (typeof x === 'number' || !isNaN(+x)) {\n\t\tif (x > 1) err('offset value is greater than 1. Fallback to 1.');\n\t\tif (x < 0) err('offset value is lower than 0. Fallback to 0.');\n\t\treturn { format: 'percent', value: Math.min(Math.max(0, x), 1) };\n\t}\n\treturn null;\n}\n","import { setIndex } from './getIndex';\n\nexport default function indexSteps(steps) {\n\tsteps.forEach((step) => setIndex(step.node, step.index));\n}\n","export default function getOffsetTop(node) {\n\tconst { top } = node.getBoundingClientRect();\n\tconst scrollTop = window.pageYOffset;\n\tconst clientTop = document.body.clientTop || 0;\n\treturn top + scrollTop - clientTop;\n}\n","// WeakMap allows the container to be garbage collected if removed from DOM\n// The state contains: scroll listener, previous scrollY, direction, and reference count\nconst scrollState = new WeakMap();\n\nfunction getScrollY(container) {\n\tif (container === window) return window.scrollY;\n\treturn container.scrollTop;\n}\n\nfunction updateScrollDirection(container) {\n\tconst state = scrollState.get(container);\n\tif (!state) return;\n\n\tconst scrollY = getScrollY(container);\n\tif (state.previousScrollY === scrollY) return;\n\n\tif (scrollY > state.previousScrollY) state.direction = 'down';\n\telse if (scrollY < state.previousScrollY) state.direction = 'up';\n\tstate.previousScrollY = scrollY;\n}\n\nfunction getDirection(container) {\n\tconst target = container || window;\n\tconst state = scrollState.get(target);\n\treturn state ? state.direction : 'down';\n}\n\nfunction addScrollListener(container) {\n\tconst target = container || window;\n\n\tif (scrollState.has(target)) {\n\t\tconst state = scrollState.get(target);\n\t\t// reference count to manage multiple listeners on the same container\n\t\tstate.count += 1;\n\t\treturn;\n\t}\n\n\tconst listener = () => updateScrollDirection(target);\n\tscrollState.set(target, {\n\t\tlistener,\n\t\tpreviousScrollY: getScrollY(target),\n\t\tdirection: 'down',\n\t\tcount: 1,\n\t});\n\n\ttarget.addEventListener('scroll', listener, { passive: true });\n}\n\nfunction removeScrollListener(container) {\n\tconst target = container || window;\n\n\tif (scrollState.has(target)) {\n\t\tconst state = scrollState.get(target);\n\t\tstate.count -= 1;\n\n\t\t// only remove listener if no more references\n\t\tif (state.count === 0) {\n\t\t\ttarget.removeEventListener('scroll', state.listener);\n\t\t\tscrollState.delete(target);\n\t\t}\n\t}\n}\n\nexport { addScrollListener, removeScrollListener, getDirection };\n","import { selectAll } from './dom';\nimport * as bug from './debug';\nimport generateId from './generateId';\nimport err from './err';\nimport getIndex, { setIndex } from './getIndex';\nimport createProgressThreshold from './createProgressThreshold';\nimport parseOffset from './parseOffset';\nimport indexSteps from './indexSteps';\nimport getOffsetTop from './getOffsetTop';\nimport {\n\taddScrollListener,\n\tgetDirection,\n\tremoveScrollListener,\n} from './scroll';\n\nfunction scrolleo() {\n\tlet cb = {};\n\n\tlet id = generateId();\n\tlet steps = [];\n\tlet globalOffset;\n\tlet containerElement;\n\tlet rootElement;\n\n\tlet resizeObserver;\n\tlet progressThreshold = 0;\n\n\tlet isEnabled = false;\n\tlet isProgress = false;\n\tlet isDebug = false;\n\tlet isTriggerOnce = false;\n\n\tlet exclude = [];\n\n\t// Batch progress callbacks with requestAnimationFrame\n\tlet pendingProgressCallbacks = new Map();\n\tlet rafScheduled = false;\n\n\t// Batch resize observer updates with requestAnimationFrame\n\tlet resizeBatch = new Set();\n\tlet resizeRafScheduled = false;\n\n\t/* HELPERS */\n\tfunction reset() {\n\t\tcb = {\n\t\t\tstepEnter: () => {},\n\t\t\tstepExit: () => {},\n\t\t\tstepProgress: () => {},\n\t\t};\n\t\texclude = [];\n\t\tpendingProgressCallbacks.clear();\n\t\trafScheduled = false;\n\t\tresizeBatch.clear();\n\t\tresizeRafScheduled = false;\n\t}\n\n\tfunction handleEnable(shouldEnable) {\n\t\tif (shouldEnable && !isEnabled) initializeObservers();\n\t\tif (!shouldEnable && isEnabled) disconnectAllObservers();\n\t\tisEnabled = shouldEnable;\n\t}\n\n\tfunction flushProgressCallbacks() {\n\t\trafScheduled = false;\n\t\tpendingProgressCallbacks.forEach(\n\t\t\t({ element, index, progress, direction, step }) => {\n\t\t\t\t// Update step progress value\n\t\t\t\tstep.progress = progress;\n\t\t\t\t// Execute callback if step is in enter state\n\t\t\t\tif (step.state === 'enter') {\n\t\t\t\t\tconst response = { element, index, progress, direction };\n\t\t\t\t\tcb.stepProgress(response);\n\t\t\t\t}\n\t\t\t}\n\t\t);\n\t\tpendingProgressCallbacks.clear();\n\t}\n\n\tfunction scheduleProgressCallback(element, progress) {\n\t\tconst index = getIndex(element);\n\t\tconst step = steps[index];\n\t\tconst currentDirection = getDirection(containerElement);\n\n\t\t// Store the latest progress update for this step\n\t\tpendingProgressCallbacks.set(index, {\n\t\t\telement,\n\t\t\tindex,\n\t\t\tprogress,\n\t\t\tdirection: currentDirection,\n\t\t\tstep,\n\t\t});\n\n\t\t// Schedule requestAnimationFrame if not already scheduled\n\t\tif (!rafScheduled) {\n\t\t\trafScheduled = true;\n\t\t\trequestAnimationFrame(flushProgressCallbacks);\n\t\t}\n\t}\n\n\t/* NOTIFY CALLBACKS */\n\tfunction notifyProgress(element, progress) {\n\t\tif (progress === undefined) return;\n\t\tscheduleProgressCallback(element, progress);\n\t}\n\n\tfunction notifyStepEnter(element) {\n\t\tconst index = getIndex(element);\n\t\tconst step = steps[index];\n\t\tconst currentDirection = getDirection(containerElement);\n\t\tconst response = { element, index, direction: currentDirection };\n\n\t\tstep.direction = currentDirection;\n\t\tstep.state = 'enter';\n\n\t\tif (!exclude[index]) cb.stepEnter(response);\n\t\tif (isTriggerOnce) exclude[index] = true;\n\t}\n\n\tfunction notifyStepExit(element, check = true) {\n\t\tconst index = getIndex(element);\n\t\tconst step = steps[index];\n\n\t\tif (!step.state) return false;\n\n\t\tconst currentDirection = getDirection(containerElement);\n\t\tconst response = { element, index, direction: currentDirection };\n\n\t\tif (isProgress) {\n\t\t\tif (currentDirection === 'down' && step.progress < 1)\n\t\t\t\tnotifyProgress(element, 1);\n\t\t\telse if (currentDirection === 'up' && step.progress > 0)\n\t\t\t\tnotifyProgress(element, 0);\n\t\t}\n\n\t\tstep.direction = currentDirection;\n\t\tstep.state = 'exit';\n\n\t\tcb.stepExit(response);\n\t}\n\n\t/* OBSERVERS - HANDLING */\n\tfunction processResizeBatch() {\n\t\tresizeRafScheduled = false;\n\t\tresizeBatch.forEach((step) => {\n\t\t\tdisconnectStepObservers(step);\n\t\t\taddStepObservers(step, isProgress);\n\t\t});\n\t\tresizeBatch.clear();\n\t}\n\n\tfunction resizeStep(entries) {\n\t\tentries.forEach((entry) => {\n\t\t\tconst index = getIndex(entry.target);\n\t\t\tconst step = steps[index];\n\t\t\tconst h = entry.target.offsetHeight;\n\t\t\tif (h !== step.height) {\n\t\t\t\tstep.height = h;\n\t\t\t\tresizeBatch.add(step);\n\t\t\t}\n\t\t});\n\n\t\t// Schedule batch processing if not already scheduled\n\t\tif (resizeBatch.size > 0 && !resizeRafScheduled) {\n\t\t\tresizeRafScheduled = true;\n\t\t\trequestAnimationFrame(processResizeBatch);\n\t\t}\n\t}\n\n\tfunction intersectStep([entry]) {\n\t\tconst { isIntersecting, target } = entry;\n\t\tif (isIntersecting) notifyStepEnter(target);\n\t\telse notifyStepExit(target);\n\t}\n\n\tfunction intersectProgress([entry]) {\n\t\tconst index = getIndex(entry.target);\n\t\tconst step = steps[index];\n\t\tconst { isIntersecting, intersectionRatio, target } = entry;\n\t\tif (isIntersecting && step.state === 'enter')\n\t\t\tnotifyProgress(target, intersectionRatio);\n\t}\n\n\t/*  OBSERVERS - CREATION */\n\tfunction disconnectStepObservers({ observers }) {\n\t\tObject.keys(observers).map((name) => {\n\t\t\tobservers[name].disconnect();\n\t\t});\n\t}\n\n\tfunction disconnectAllObservers() {\n\t\tsteps.forEach(disconnectStepObservers);\n\t\tif (resizeObserver) resizeObserver.disconnect();\n\t}\n\n\tfunction addResizeObserver() {\n\t\tresizeObserver = new ResizeObserver(resizeStep);\n\t\tsteps.forEach((step) => resizeObserver.observe(step.node));\n\t}\n\n\tfunction addStepObservers(step, isProgress) {\n\t\taddStepIntersectionObserver(step);\n\t\tif (isProgress) addProgressIntersectionObserver(step);\n\t}\n\n\tfunction addStepIntersectionObserver(step) {\n\t\tconst h = window.innerHeight;\n\t\tconst off = step.offset || globalOffset;\n\t\tconst factor = off.format === 'pixels' ? 1 : h;\n\t\tconst offset = off.value * factor;\n\t\tconst marginTop = step.height / 2 - offset;\n\t\tconst marginBottom = step.height / 2 - (h - offset);\n\t\tconst rootMargin = `${marginTop}px 0px ${marginBottom}px 0px`;\n\t\tconst root = rootElement;\n\n\t\tconst threshold = 0.5;\n\t\tconst options = { rootMargin, threshold, root };\n\t\tconst observer = new IntersectionObserver(intersectStep, options);\n\n\t\tobserver.observe(step.node);\n\t\tstep.observers.step = observer;\n\n\t\tif (isDebug) bug.update({ id, step, marginTop, marginBottom });\n\t}\n\n\tfunction addProgressIntersectionObserver(step) {\n\t\tconst h = window.innerHeight;\n\t\tconst off = step.offset || globalOffset;\n\t\tconst factor = off.format === 'pixels' ? 1 : h;\n\t\tconst offset = off.value * factor;\n\t\tconst marginTop = -offset + step.height;\n\t\tconst marginBottom = offset - h;\n\t\tconst rootMargin = `${marginTop}px 0px ${marginBottom}px 0px`;\n\n\t\tconst threshold = createProgressThreshold(step.height, progressThreshold);\n\t\tconst options = { rootMargin, threshold };\n\t\tconst observer = new IntersectionObserver(intersectProgress, options);\n\n\t\tobserver.observe(step.node);\n\t\tstep.observers.progress = observer;\n\t}\n\n\tfunction initializeObservers() {\n\t\tdisconnectAllObservers();\n\t\taddResizeObserver();\n\t\tsteps.forEach((step) => addStepObservers(step, isProgress));\n\t}\n\n\t/* SETUP */\n\tconst S = {};\n\n\tS.setup = ({\n\t\tstep,\n\t\tparent,\n\t\toffset = 0.5,\n\t\tthreshold = 4,\n\t\tprogress = false,\n\t\tonce = false,\n\t\tdebug = false,\n\t\tcontainer = undefined,\n\t\troot = null,\n\t}) => {\n\t\taddScrollListener(container);\n\n\t\t// Batch layout reads to reduce layout thrashing\n\t\tconst nodes = selectAll(step, parent);\n\t\tconst layoutData = nodes.map((node) => ({\n\t\t\theight: node.offsetHeight,\n\t\t\ttop: getOffsetTop(node),\n\t\t}));\n\n\t\tsteps = nodes.map((node, index) => ({\n\t\t\tindex,\n\t\t\tdirection: undefined,\n\t\t\theight: layoutData[index].height,\n\t\t\tnode,\n\t\t\tobservers: {},\n\t\t\toffset: parseOffset(node.dataset.offset),\n\t\t\ttop: layoutData[index].top,\n\t\t\tprogress: 0,\n\t\t\tstate: undefined,\n\t\t}));\n\n\t\tif (!steps.length) {\n\t\t\terr('no step elements');\n\t\t\treturn S;\n\t\t}\n\n\t\tisProgress = progress;\n\t\tisTriggerOnce = once;\n\t\t// Cleanup debug overlay if debug is being disabled\n\t\tif (isDebug && !debug) {\n\t\t\tbug.cleanup();\n\t\t}\n\t\tisDebug = debug;\n\t\tprogressThreshold = Math.max(1, +threshold);\n\t\tglobalOffset = parseOffset(offset);\n\t\tcontainerElement = container;\n\t\trootElement = root;\n\n\t\treset();\n\t\tindexSteps(steps);\n\t\thandleEnable(true);\n\t\treturn S;\n\t};\n\n\tS.enable = () => {\n\t\thandleEnable(true);\n\t\treturn S;\n\t};\n\n\tS.disable = () => {\n\t\thandleEnable(false);\n\t\treturn S;\n\t};\n\n\tS.destroy = () => {\n\t\thandleEnable(false);\n\t\treset();\n\t\tremoveScrollListener(containerElement);\n\t\tif (isDebug) {\n\t\t\tbug.cleanup();\n\t\t}\n\t\tsteps = [];\n\t\treturn S;\n\t};\n\n\tS.resize = () => {\n\t\tinitializeObservers();\n\t\treturn S;\n\t};\n\n\tS.offset = (x) => {\n\t\tif (x === null || x === undefined) return globalOffset.value;\n\t\tglobalOffset = parseOffset(x);\n\t\tinitializeObservers();\n\t\treturn S;\n\t};\n\n\tS.onStepEnter = (f) => {\n\t\tif (typeof f === 'function') cb.stepEnter = f;\n\t\telse err('onStepEnter requires a function');\n\t\treturn S;\n\t};\n\n\tS.onStepExit = (f) => {\n\t\tif (typeof f === 'function') cb.stepExit = f;\n\t\telse err('onStepExit requires a function');\n\t\treturn S;\n\t};\n\n\tS.onStepProgress = (f) => {\n\t\tif (typeof f === 'function') cb.stepProgress = f;\n\t\telse err('onStepProgress requires a function');\n\t\treturn S;\n\t};\n\treturn S;\n}\n\nexport default scrolleo;\n"],"names":["selectAll","selector","parent","overlayElement","create","el","p","update","id","step","marginTop","height","cleanup","generateId","alphabet","date","result","i","char","err","msg","stepIndexMap","setIndex","node","index","getIndex","createProgressThreshold","threshold","count","t","ratio","parseOffset","x","v","indexSteps","steps","getOffsetTop","top","scrollTop","clientTop","scrollState","getScrollY","container","updateScrollDirection","state","scrollY","getDirection","target","addScrollListener","listener","removeScrollListener","scrolleo","cb","globalOffset","containerElement","rootElement","resizeObserver","progressThreshold","isEnabled","isProgress","isDebug","isTriggerOnce","exclude","pendingProgressCallbacks","rafScheduled","resizeBatch","resizeRafScheduled","reset","handleEnable","shouldEnable","initializeObservers","disconnectAllObservers","flushProgressCallbacks","element","progress","direction","response","scheduleProgressCallback","currentDirection","notifyProgress","notifyStepEnter","notifyStepExit","check","processResizeBatch","disconnectStepObservers","addStepObservers","resizeStep","entries","entry","h","intersectStep","isIntersecting","intersectProgress","intersectionRatio","observers","name","addResizeObserver","addStepIntersectionObserver","addProgressIntersectionObserver","off","factor","offset","marginBottom","options","observer","bug.update","rootMargin","S","once","debug","root","nodes","layoutData","bug.cleanup","f"],"mappings":"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"}