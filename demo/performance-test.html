<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<title>Scrollama Demo: Performance Test</title>
		<meta
			name="description"
			content="Scrollama Demo: Performance monitoring with multiple instances"
		/>
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<link rel="stylesheet" href="style.css" />
		<style>
			body {
				background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
				min-height: 500vh;
			}

			/* Performance Monitor */
			#performance-monitor {
				position: fixed;
				top: 10px;
				right: 10px;
				background: rgba(0, 0, 0, 0.8);
				color: #0f0;
				padding: 15px;
				border-radius: 8px;
				font-family: 'Courier New', monospace;
				font-size: 12px;
				z-index: 10000;
				min-width: 250px;
				backdrop-filter: blur(10px);
			}

			#performance-monitor h3 {
				margin: 0 0 10px 0;
				color: #fff;
				font-size: 14px;
			}

			#performance-monitor .metric {
				margin: 5px 0;
				display: flex;
				justify-content: space-between;
			}

			#performance-monitor .metric-label {
				color: #aaa;
			}

			#performance-monitor .metric-value {
				color: #0f0;
				font-weight: bold;
			}

			#performance-monitor .metric-value.warning {
				color: #ff0;
			}

			#performance-monitor .metric-value.critical {
				color: #f00;
			}

			/* Section Styles */
			.section {
				position: relative;
				margin: 100vh 0;
				padding: 50px 0;
			}

			.section-title {
				text-align: center;
				color: #fff;
				font-size: 2.5rem;
				margin-bottom: 50px;
				text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
			}

			.scroll-container {
				position: relative;
				max-width: 1200px;
				margin: 0 auto;
				padding: 0 20px;
			}

			/* Step Styles */
			.step {
				margin: 4rem auto;
				padding: 3rem;
				background: rgba(255, 255, 255, 0.95);
				border-radius: 20px;
				box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
				position: relative;
				overflow: hidden;
				min-height: 300px;
				transition: all 0.3s ease;
			}

			.step.is-active {
				box-shadow: 0 20px 60px rgba(102, 126, 234, 0.4);
				transform: scale(1.02);
			}

			.step-number {
				position: absolute;
				top: 20px;
				right: 20px;
				width: 50px;
				height: 50px;
				background: #667eea;
				color: #fff;
				border-radius: 50%;
				display: flex;
				align-items: center;
				justify-content: center;
				font-weight: bold;
				font-size: 1.2rem;
			}

			.step-content {
				position: relative;
				z-index: 1;
			}

			.step-title {
				font-size: 2rem;
				margin-bottom: 1rem;
				color: #333;
			}

			.step-description {
				font-size: 1.1rem;
				line-height: 1.6;
				color: #666;
				margin-bottom: 1.5rem;
			}

			.step-progress {
				height: 4px;
				background: rgba(102, 126, 234, 0.2);
				border-radius: 2px;
				margin-top: 1.5rem;
				overflow: hidden;
			}

			.step-progress-bar {
				height: 100%;
				background: linear-gradient(90deg, #667eea, #764ba2);
				width: 0%;
				transition: width 0.1s linear;
			}
		</style>
	</head>
	<body>
		<main>
			<nav>
				<a href="index.html">scrollama.js</a>
				<div class="nav__examples">
					<p>Examples:</p>
					<a href="basic.html">Basic</a>
					<a href="progress.html">Progress</a>
					<a href="sticky-side.html">Sticky Side</a>
					<a href="sticky-overlay.html">Sticky Overlay</a>
					<a href="percentage-offset.html">Percentage Offset</a>
					<a href="pixel-offset.html">Pixel Offset</a>
					<a href="multiple.html">Multiple Instances</a>
					<a href="scroll-parent.html">Nested Scroll Container</a>
					<a href="performance-test.html">Performance Test</a>
				</div>
			</nav>
			<section id="intro">
				<h1 class="intro__hed">Performance Test</h1>
				<p class="intro__dek">
					This demo tests scrollama performance with multiple instances and many
					steps. Monitor FPS, frame time, and callback rates in real-time.
				</p>
			</section>

			<!-- Performance Monitor -->
			<div id="performance-monitor">
				<h3>Performance Monitor</h3>
				<div class="metric">
					<span class="metric-label">FPS:</span>
					<span class="metric-value" id="fps">--</span>
				</div>
				<div class="metric">
					<span class="metric-label">Frame Time:</span>
					<span class="metric-value" id="frame-time">--</span>
				</div>
				<div class="metric">
					<span class="metric-label">Callbacks/sec:</span>
					<span class="metric-value" id="callbacks-per-sec">--</span>
				</div>
				<div class="metric">
					<span class="metric-label">Active Steps:</span>
					<span class="metric-value" id="active-steps">--</span>
				</div>
				<div class="metric">
					<span class="metric-label">Memory (MB):</span>
					<span class="metric-value" id="memory">--</span>
				</div>
			</div>

			<!-- Section 1 -->
			<section class="section" id="section-1">
				<div class="section-title">Performance Test Section 1</div>
				<div class="scroll-container" id="container-1">
					<!-- Steps will be generated by JavaScript -->
				</div>
			</section>

			<!-- Section 2 -->
			<section class="section" id="section-2">
				<div class="section-title">Performance Test Section 2</div>
				<div class="scroll-container" id="container-2">
					<!-- Steps will be generated by JavaScript -->
				</div>
			</section>

			<!-- Section 3 -->
			<section class="section" id="section-3">
				<div class="section-title">Performance Test Section 3</div>
				<div class="scroll-container" id="container-3">
					<!-- Steps will be generated by JavaScript -->
				</div>
			</section>
		</main>

		<script src="debug-utils.js"></script>
		<script type="module">
			import scrollama from '../dist/scrollama.js';

			// Performance monitoring
			const perfMonitor = {
				fps: 0,
				frameTime: 0,
				callbacksPerSecond: 0,
				activeSteps: 0,
				memory: 0,

				callbackCount: 0,
				lastCallbackReset: Date.now(),
				lastFrameTime: performance.now(),
				frameCount: 0,
				frameStartTime: performance.now(),

				init() {
					this.updateDisplay();
					this.startFPSMonitor();
					this.startMemoryMonitor();
					setInterval(() => this.updateDisplay(), 100);
				},

				startFPSMonitor() {
					const measureFPS = () => {
						const now = performance.now();
						const delta = now - this.lastFrameTime;
						this.frameCount++;

						if (delta >= 1000) {
							this.fps = Math.round((this.frameCount * 1000) / delta);
							this.frameTime = Math.round(delta / this.frameCount);
							this.frameCount = 0;
							this.lastFrameTime = now;
						}

						requestAnimationFrame(measureFPS);
					};
					requestAnimationFrame(measureFPS);
				},

				startMemoryMonitor() {
					if (performance.memory) {
						setInterval(() => {
							this.memory = Math.round(
								performance.memory.usedJSHeapSize / 1048576
							);
						}, 1000);
					}
				},

				recordCallback() {
					this.callbackCount++;
					const now = Date.now();
					if (now - this.lastCallbackReset >= 1000) {
						this.callbacksPerSecond = this.callbackCount;
						this.callbackCount = 0;
						this.lastCallbackReset = now;
					}
				},

				updateActiveSteps(count) {
					this.activeSteps = count;
				},

				updateDisplay() {
					const updateMetric = (id, value, unit = '') => {
						const el = document.getElementById(id);
						if (el) {
							el.textContent = value !== undefined ? value + unit : '--';

							// Add warning/critical classes
							el.classList.remove('warning', 'critical');
							if (id === 'fps' && value < 30) {
								el.classList.add('critical');
							} else if (id === 'fps' && value < 50) {
								el.classList.add('warning');
							} else if (id === 'frame-time' && value > 33) {
								el.classList.add('critical');
							} else if (id === 'frame-time' && value > 20) {
								el.classList.add('warning');
							} else if (id === 'callbacks-per-sec' && value > 500) {
								el.classList.add('critical');
							} else if (id === 'callbacks-per-sec' && value > 200) {
								el.classList.add('warning');
							}
						}
					};

					updateMetric('fps', this.fps);
					updateMetric('frame-time', this.frameTime, 'ms');
					updateMetric('callbacks-per-sec', this.callbacksPerSecond);
					updateMetric('active-steps', this.activeSteps);
					updateMetric('memory', this.memory, ' MB');
				},
			};

			// Configuration
			const CONFIG = {
				numSections: 3,
				stepsPerSection: 15,
				progressThreshold: 4,
			};

			// Generate steps for a container
			function generateSteps(containerId, sectionNum) {
				const container = document.getElementById(containerId);
				const steps = [];

				for (let i = 0; i < CONFIG.stepsPerSection; i++) {
					const step = document.createElement('div');
					step.className = 'step';
					step.innerHTML = `
					<div class="step-number">${i + 1}</div>
					<div class="step-content">
						<h2 class="step-title">Section ${sectionNum} - Step ${i + 1}</h2>
						<p class="step-description">
							This is a performance test step with progress tracking enabled to stress test the callback system.
						</p>
						<div class="step-progress">
							<div class="step-progress-bar"></div>
						</div>
					</div>
				`;
					container.appendChild(step);
					steps.push(step);
				}

				return steps;
			}

			// Create scrollama instances
			const scrollers = [];
			let activeStepsCount = 0;

			function initScrollama() {
				// Generate all steps
				for (let i = 1; i <= CONFIG.numSections; i++) {
					generateSteps(`container-${i}`, i);
				}

				// Create scrollama instances for each section
				for (let i = 1; i <= CONFIG.numSections; i++) {
					const scroller = scrollama();
					const setupOptions = {
						step: `#container-${i} .step`,
						progress: true,
						threshold: CONFIG.progressThreshold,
						offset: 0.5,
						debug: false,
					};

					const handlers = {
						onStepEnter: (response) => {
							perfMonitor.recordCallback();
							response.element.classList.add('is-active');
							activeStepsCount++;
							perfMonitor.updateActiveSteps(activeStepsCount);
						},
						onStepExit: (response) => {
							perfMonitor.recordCallback();
							response.element.classList.remove('is-active');
							activeStepsCount--;
							perfMonitor.updateActiveSteps(activeStepsCount);
						},
						onStepProgress: (response) => {
							perfMonitor.recordCallback();
							const progressBar =
								response.element.querySelector('.step-progress-bar');
							if (progressBar) {
								progressBar.style.width = response.progress * 100 + '%';
							}
						},
					};

					scroller
						.setup(setupOptions)
						.onStepEnter(handlers.onStepEnter)
						.onStepExit(handlers.onStepExit)
						.onStepProgress(handlers.onStepProgress);

					scrollers.push({ scroller, setupOptions, handlers });
				}

				// Handle window resize
				let resizeTimeout;
				window.addEventListener('resize', () => {
					clearTimeout(resizeTimeout);
					resizeTimeout = setTimeout(() => {
						scrollers.forEach(({ scroller }) => scroller.resize());
					}, 100);
				});

				// Create debug toggle for first instance (all instances will share debug state)
				if (scrollers.length > 0) {
					const firstInstance = scrollers[0];
					const toggle = createDebugToggle(
						firstInstance.scroller,
						firstInstance.setupOptions,
						firstInstance.handlers
					);

					// Override toggle to update all instances
					const originalToggle = toggle.toggle;
					toggle.toggle = function () {
						const newDebug = !toggle.isEnabled();
						scrollers.forEach(({ scroller, setupOptions, handlers }) => {
							scroller.setup({ ...setupOptions, debug: newDebug });
							scroller.onStepEnter(handlers.onStepEnter);
							scroller.onStepExit(handlers.onStepExit);
							scroller.onStepProgress(handlers.onStepProgress);
							scroller.resize();
						});
						originalToggle();
					};
				}

				console.log(`Performance test initialized:`);
				console.log(`- ${CONFIG.numSections} scrollama instances`);
				console.log(
					`- ${CONFIG.numSections * CONFIG.stepsPerSection} total steps`
				);
				console.log(`- Progress tracking enabled on all instances`);
			}

			// Initialize performance monitoring
			perfMonitor.init();

			// Initialize scrollama after DOM is ready
			if (document.readyState === 'loading') {
				document.addEventListener('DOMContentLoaded', initScrollama);
			} else {
				initScrollama();
			}
		</script>
	</body>
</html>
