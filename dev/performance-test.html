<!DOCTYPE html>
<html>

<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
	<title>Scrollama: Performance Test</title>
	<meta name="description" content="Performance test case for scrollama library" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<style>
		* {
			box-sizing: border-box;
		}

		html,
		body {
			margin: 0;
			padding: 0;
			font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
		}

		body {
			background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
			min-height: 500vh;
		}

		/* Performance Monitor */
		#performance-monitor {
			position: fixed;
			top: 10px;
			right: 10px;
			background: rgba(0, 0, 0, 0.8);
			color: #0f0;
			padding: 15px;
			border-radius: 8px;
			font-family: 'Courier New', monospace;
			font-size: 12px;
			z-index: 10000;
			min-width: 250px;
			backdrop-filter: blur(10px);
		}

		#performance-monitor h3 {
			margin: 0 0 10px 0;
			color: #fff;
			font-size: 14px;
		}

		#performance-monitor .metric {
			margin: 5px 0;
			display: flex;
			justify-content: space-between;
		}

		#performance-monitor .metric-label {
			color: #aaa;
		}

		#performance-monitor .metric-value {
			color: #0f0;
			font-weight: bold;
		}

		#performance-monitor .metric-value.warning {
			color: #ff0;
		}

		#performance-monitor .metric-value.critical {
			color: #f00;
		}

		/* Section Styles */
		.section {
			position: relative;
			margin: 100vh 0;
			padding: 50px 0;
		}

		.section-title {
			text-align: center;
			color: #fff;
			font-size: 2.5rem;
			margin-bottom: 50px;
			text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
		}

		.scroll-container {
			position: relative;
			max-width: 1200px;
			margin: 0 auto;
			padding: 0 20px;
		}

		/* Step Styles with Performance-Intensive Animations */
		.step {
			margin: 4rem auto;
			padding: 3rem;
			background: rgba(255, 255, 255, 0.95);
			border-radius: 20px;
			box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
			position: relative;
			overflow: hidden;
			min-height: 300px;
			transition: all 0.3s ease;
		}

		/* Performance-intensive CSS animations */
		.step::before {
			content: '';
			position: absolute;
			top: -50%;
			left: -50%;
			width: 200%;
			height: 200%;
			background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.3), transparent);
			transform: rotate(0deg);
			transition: transform 0.5s ease;
		}

		.step.is-active::before {
			transform: rotate(360deg);
			animation: shimmer 2s infinite;
		}

		@keyframes shimmer {
			0% {
				transform: rotate(0deg) translateX(-50%) translateY(-50%);
			}
			100% {
				transform: rotate(360deg) translateX(-50%) translateY(-50%);
			}
		}

		.step-content {
			position: relative;
			z-index: 1;
		}

		.step-title {
			font-size: 2rem;
			margin-bottom: 1rem;
			color: #333;
			transform: translateY(0);
			transition: transform 0.3s ease, color 0.3s ease;
		}

		.step.is-active .step-title {
			transform: translateY(-10px) scale(1.05);
			color: #667eea;
			animation: pulse 1s ease-in-out infinite;
		}

		@keyframes pulse {
			0%, 100% {
				transform: translateY(-10px) scale(1.05);
			}
			50% {
				transform: translateY(-10px) scale(1.1);
			}
		}

		.step-description {
			font-size: 1.1rem;
			line-height: 1.6;
			color: #666;
			margin-bottom: 1.5rem;
			opacity: 0.8;
			transition: opacity 0.3s ease;
		}

		.step.is-active .step-description {
			opacity: 1;
		}

		/* Performance-intensive visual elements */
		.step-visual {
			width: 100%;
			height: 200px;
			background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
			border-radius: 10px;
			margin: 1.5rem 0;
			position: relative;
			overflow: hidden;
			transform: scale(1) rotate(0deg);
			filter: blur(0px) brightness(1);
			transition: all 0.3s ease;
		}

		.step.is-active .step-visual {
			transform: scale(1.1) rotate(5deg);
			filter: blur(2px) brightness(1.2);
			animation: visualPulse 2s ease-in-out infinite;
		}

		@keyframes visualPulse {
			0%, 100% {
				transform: scale(1.1) rotate(5deg);
				filter: blur(2px) brightness(1.2);
			}
			50% {
				transform: scale(1.15) rotate(-5deg);
				filter: blur(3px) brightness(1.4);
			}
		}

		.step-visual::after {
			content: '';
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background: radial-gradient(circle at center, rgba(255, 255, 255, 0.3), transparent);
			animation: ripple 3s ease-in-out infinite;
		}

		@keyframes ripple {
			0%, 100% {
				transform: scale(0.8);
				opacity: 0.5;
			}
			50% {
				transform: scale(1.2);
				opacity: 0.8;
			}
		}

		/* Progress indicator */
		.step-progress {
			height: 4px;
			background: rgba(102, 126, 234, 0.2);
			border-radius: 2px;
			margin-top: 1.5rem;
			overflow: hidden;
			position: relative;
		}

		.step-progress-bar {
			height: 100%;
			background: linear-gradient(90deg, #667eea, #764ba2);
			width: 0%;
			transition: width 0.1s linear;
			box-shadow: 0 0 10px rgba(102, 126, 234, 0.5);
		}

		.step-progress-bar::after {
			content: '';
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.5), transparent);
			animation: progressShine 1s linear infinite;
		}

		@keyframes progressShine {
			0% {
				transform: translateX(-100%);
			}
			100% {
				transform: translateX(100%);
			}
		}

		/* Multiple animated particles */
		.step-particles {
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			pointer-events: none;
			opacity: 0;
			transition: opacity 0.3s ease;
		}

		.step.is-active .step-particles {
			opacity: 1;
		}

		.particle {
			position: absolute;
			width: 8px;
			height: 8px;
			background: #667eea;
			border-radius: 50%;
			animation: float 3s ease-in-out infinite;
		}

		@keyframes float {
			0%, 100% {
				transform: translate(0, 0) scale(1);
				opacity: 0.7;
			}
			50% {
				transform: translate(20px, -20px) scale(1.5);
				opacity: 1;
			}
		}

		/* Additional performance-intensive effects */
		.step.is-active {
			box-shadow: 0 20px 60px rgba(102, 126, 234, 0.4);
			transform: perspective(1000px) rotateX(2deg);
			backdrop-filter: blur(10px);
		}

		.step-number {
			position: absolute;
			top: 20px;
			right: 20px;
			width: 50px;
			height: 50px;
			background: #667eea;
			color: #fff;
			border-radius: 50%;
			display: flex;
			align-items: center;
			justify-content: center;
			font-weight: bold;
			font-size: 1.2rem;
			transform: scale(1) rotate(0deg);
			transition: all 0.3s ease;
		}

		.step.is-active .step-number {
			transform: scale(1.2) rotate(360deg);
			animation: numberSpin 2s linear infinite;
		}

		@keyframes numberSpin {
			0% {
				transform: scale(1.2) rotate(0deg);
			}
			100% {
				transform: scale(1.2) rotate(360deg);
			}
		}

		/* Complex gradient animations */
		.step-gradient {
			position: absolute;
			top: 0;
			left: 0;
			right: 0;
			bottom: 0;
			background: linear-gradient(45deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
			opacity: 0;
			transition: opacity 0.3s ease;
			animation: gradientShift 4s ease-in-out infinite;
		}

		.step.is-active .step-gradient {
			opacity: 1;
		}

		@keyframes gradientShift {
			0%, 100% {
				background: linear-gradient(45deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
			}
			50% {
				background: linear-gradient(135deg, rgba(118, 75, 162, 0.1), rgba(102, 126, 234, 0.1));
			}
		}
	</style>
</head>

<body>
	<!-- Performance Monitor -->
	<div id="performance-monitor">
		<h3>Performance Monitor</h3>
		<div class="metric">
			<span class="metric-label">FPS:</span>
			<span class="metric-value" id="fps">--</span>
		</div>
		<div class="metric">
			<span class="metric-label">Frame Time:</span>
			<span class="metric-value" id="frame-time">--</span>
		</div>
		<div class="metric">
			<span class="metric-label">Callbacks/sec:</span>
			<span class="metric-value" id="callbacks-per-sec">--</span>
		</div>
		<div class="metric">
			<span class="metric-label">Active Steps:</span>
			<span class="metric-value" id="active-steps">--</span>
		</div>
		<div class="metric">
			<span class="metric-label">Memory (MB):</span>
			<span class="metric-value" id="memory">--</span>
		</div>
		<div class="metric">
			<span class="metric-label">Long Tasks:</span>
			<span class="metric-value" id="long-tasks">--</span>
		</div>
	</div>

	<!-- Section 1 -->
	<section class="section" id="section-1">
		<div class="section-title">Performance Test Section 1</div>
		<div class="scroll-container" id="container-1">
			<!-- Steps will be generated by JavaScript -->
		</div>
	</section>

	<!-- Section 2 -->
	<section class="section" id="section-2">
		<div class="section-title">Performance Test Section 2</div>
		<div class="scroll-container" id="container-2">
			<!-- Steps will be generated by JavaScript -->
		</div>
	</section>

	<!-- Section 3 -->
	<section class="section" id="section-3">
		<div class="section-title">Performance Test Section 3</div>
		<div class="scroll-container" id="container-3">
			<!-- Steps will be generated by JavaScript -->
		</div>
	</section>

	<!-- Section 4 -->
	<section class="section" id="section-4">
		<div class="section-title">Performance Test Section 4</div>
		<div class="scroll-container" id="container-4">
			<!-- Steps will be generated by JavaScript -->
		</div>
	</section>

	<!-- Section 5 -->
	<section class="section" id="section-5">
		<div class="section-title">Performance Test Section 5</div>
		<div class="scroll-container" id="container-5">
			<!-- Steps will be generated by JavaScript -->
		</div>
	</section>

	<script src="../build/scrollama.js"></script>
	<script>
		// Performance monitoring
		const perfMonitor = {
			fps: 0,
			frameTime: 0,
			callbacksPerSecond: 0,
			activeSteps: 0,
			memory: 0,
			longTasks: 0,
			
			callbackCount: 0,
			lastCallbackReset: Date.now(),
			lastFrameTime: performance.now(),
			frameCount: 0,
			frameStartTime: performance.now(),
			
			init() {
				this.updateDisplay();
				this.startFPSMonitor();
				this.startMemoryMonitor();
				this.startLongTaskMonitor();
				setInterval(() => this.updateDisplay(), 100);
			},
			
			startFPSMonitor() {
				const measureFPS = () => {
					const now = performance.now();
					const delta = now - this.lastFrameTime;
					this.frameCount++;
					
					if (delta >= 1000) {
						this.fps = Math.round((this.frameCount * 1000) / delta);
						this.frameTime = Math.round(delta / this.frameCount);
						this.frameCount = 0;
						this.lastFrameTime = now;
					}
					
					requestAnimationFrame(measureFPS);
				};
				requestAnimationFrame(measureFPS);
			},
			
			startMemoryMonitor() {
				if (performance.memory) {
					setInterval(() => {
						this.memory = Math.round(performance.memory.usedJSHeapSize / 1048576);
					}, 1000);
				}
			},
			
			startLongTaskMonitor() {
				if ('PerformanceObserver' in window) {
					try {
						const observer = new PerformanceObserver((list) => {
							for (const entry of list.getEntries()) {
								if (entry.duration > 50) {
									this.longTasks++;
								}
							}
						});
						observer.observe({ entryTypes: ['longtask', 'measure'] });
					} catch (e) {
						console.warn('Long task monitoring not supported');
					}
				}
			},
			
			recordCallback() {
				this.callbackCount++;
				const now = Date.now();
				if (now - this.lastCallbackReset >= 1000) {
					this.callbacksPerSecond = this.callbackCount;
					this.callbackCount = 0;
					this.lastCallbackReset = now;
				}
			},
			
			updateActiveSteps(count) {
				this.activeSteps = count;
			},
			
			updateDisplay() {
				const updateMetric = (id, value, unit = '') => {
					const el = document.getElementById(id);
					if (el) {
						el.textContent = value !== undefined ? value + unit : '--';
						
						// Add warning/critical classes
						el.classList.remove('warning', 'critical');
						if (id === 'fps' && value < 30) {
							el.classList.add('critical');
						} else if (id === 'fps' && value < 50) {
							el.classList.add('warning');
						} else if (id === 'frame-time' && value > 33) {
							el.classList.add('critical');
						} else if (id === 'frame-time' && value > 20) {
							el.classList.add('warning');
						} else if (id === 'callbacks-per-sec' && value > 200) {
							el.classList.add('warning');
						} else if (id === 'callbacks-per-sec' && value > 500) {
							el.classList.add('critical');
						}
					}
				};
				
				updateMetric('fps', this.fps);
				updateMetric('frame-time', this.frameTime, 'ms');
				updateMetric('callbacks-per-sec', this.callbacksPerSecond);
				updateMetric('active-steps', this.activeSteps);
				updateMetric('memory', this.memory, ' MB');
				updateMetric('long-tasks', this.longTasks);
			}
		};

		// Configuration
		const CONFIG = {
			numSections: 5,
			stepsPerSection: 25, // 25 steps per section = 125 total steps
			progressThreshold: 2, // More granular = more callbacks
		};

		// Generate steps for a container
		function generateSteps(containerId, sectionNum) {
			const container = document.getElementById(containerId);
			const steps = [];
			
			for (let i = 0; i < CONFIG.stepsPerSection; i++) {
				const step = document.createElement('div');
				step.className = 'step';
				step.innerHTML = `
					<div class="step-gradient"></div>
					<div class="step-particles">
						${Array.from({ length: 10 }, (_, j) => 
							`<div class="particle" style="left: ${j * 10}%; top: ${j * 5}%; animation-delay: ${j * 0.2}s;"></div>`
						).join('')}
					</div>
					<div class="step-number">${i + 1}</div>
					<div class="step-content">
						<h2 class="step-title">Section ${sectionNum} - Step ${i + 1}</h2>
						<p class="step-description">
							This is a performance test step with intensive CSS animations including transforms, 
							filters, gradients, and multiple keyframe animations. The progress tracking is enabled 
							to stress test the callback system.
						</p>
						<div class="step-visual"></div>
						<div class="step-progress">
							<div class="step-progress-bar"></div>
						</div>
					</div>
				`;
				container.appendChild(step);
				steps.push(step);
			}
			
			return steps;
		}

		// Create scrollama instances
		const scrollers = [];
		let activeStepsCount = 0;

		function initScrollama() {
			const debug = document.location.search.includes('debug');

			// Generate all steps
			const allSteps = [];
			for (let i = 1; i <= CONFIG.numSections; i++) {
				const steps = generateSteps(`container-${i}`, i);
				allSteps.push(...steps);
			}

			// Create scrollama instances for each section
			for (let i = 1; i <= CONFIG.numSections; i++) {
				const scroller = scrollama();
				
				scroller
					.setup({
						step: `#container-${i} .step`,
						progress: true, // Enable progress tracking for maximum callbacks
						threshold: CONFIG.progressThreshold, // Granular threshold
						offset: 0.5,
						debug,
					})
					.onStepEnter((response) => {
						perfMonitor.recordCallback();
						response.element.classList.add('is-active');
						activeStepsCount++;
						perfMonitor.updateActiveSteps(activeStepsCount);
					})
					.onStepExit((response) => {
						perfMonitor.recordCallback();
						response.element.classList.remove('is-active');
						activeStepsCount--;
						perfMonitor.updateActiveSteps(activeStepsCount);
					})
					.onStepProgress((response) => {
						perfMonitor.recordCallback();
						const progressBar = response.element.querySelector('.step-progress-bar');
						if (progressBar) {
							progressBar.style.width = (response.progress * 100) + '%';
						}
					});

				scrollers.push(scroller);
			}

			// Handle window resize
			let resizeTimeout;
			window.addEventListener('resize', () => {
				clearTimeout(resizeTimeout);
				resizeTimeout = setTimeout(() => {
					scrollers.forEach(scroller => scroller.resize());
				}, 100);
			});

			console.log(`Performance test initialized:`);
			console.log(`- ${CONFIG.numSections} scrollama instances`);
			console.log(`- ${CONFIG.numSections * CONFIG.stepsPerSection} total steps`);
			console.log(`- Progress tracking enabled on all instances`);
			console.log(`- Threshold: ${CONFIG.progressThreshold}px`);
			console.log(`- Estimated observers: ${CONFIG.numSections * CONFIG.stepsPerSection * 2} (with progress)`);
		}

		// Initialize performance monitoring
		perfMonitor.init();

		// Initialize scrollama after DOM is ready
		if (document.readyState === 'loading') {
			document.addEventListener('DOMContentLoaded', initScrollama);
		} else {
			initScrollama();
		}

		// Performance marks for setup time
		performance.mark('scrollama-setup-start');
		setTimeout(() => {
			performance.mark('scrollama-setup-end');
			performance.measure('scrollama-setup', 'scrollama-setup-start', 'scrollama-setup-end');
			const measure = performance.getEntriesByName('scrollama-setup')[0];
			console.log(`Setup time: ${Math.round(measure.duration)}ms`);
		}, 100);
	</script>
</body>

</html>
